★再起動
service mysqld restart

★ログイン
mysql -hlocalhost -P3306 -uroot TESTDB
mysql -hlocalhost -P3306 -uUSER TESTDB
mysql -hlocalhost -P3306 -uUSER_C -pPASSWORD DB_C
mysql -hlocalhost -P3306 -uUSER_S -pPASSWORD DB_S

★データベース作成
CREATE DATABASE IF NOT EXISTS TESTDB
DEFAULT CHARACTER SET UTF8;
CREATE DATABASE IF NOT EXISTS DB_C
DEFAULT CHARACTER SET UTF8;
CREATE DATABASE IF NOT EXISTS DB_S
DEFAULT CHARACTER SET UTF8;

★ユーザ作成
DROP USER 'USER';
DROP USER 'USER_C';
DROP USER 'USER_S';

CREATE USER 'USER' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON TESTDB.* TO 'USER'@'localhost' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON TESTDB.* TO 'USER'@'cdh5-1' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON TESTDB.* TO 'USER'@'cdh5-2' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON TESTDB.* TO 'USER'@'cdh5-3' IDENTIFIED BY 'PASSWORD';

CREATE USER 'USER_C' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_C.* TO 'USER_C'@'localhost' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_C.* TO 'USER_C'@'cdh5-1' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_C.* TO 'USER_C'@'cdh5-2' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_C.* TO 'USER_C'@'cdh5-3' IDENTIFIED BY 'PASSWORD';

CREATE USER 'USER_S' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_S.* TO 'USER_S'@'localhost' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_S.* TO 'USER_S'@'cdh5-1' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_S.* TO 'USER_S'@'cdh5-2' IDENTIFIED BY 'PASSWORD';
GRANT ALL PRIVILEGES ON DB_S.* TO 'USER_S'@'cdh5-3' IDENTIFIED BY 'PASSWORD';

※MySQL5.1（Linux版）では、DB名、テーブル名などの大文字・小文字を意識する。

★Customer
テーブル作成、データインポート
cd /work/init_data/customer
mysql -hlocalhost -P3306 -uroot DB_C < CUSTOMER_DDL_MYSQL.sql
mysql -hlocalhost -P3306 -uroot DB_C < CUSTOMER_5M_LOAD_TO_MYSQL.sql

以下のSQLを何度か繰り返し、20万件毎にJOB_IDを0からNULLに更新する
UPDATE CUSTOMER2 SET JOB_ID=NULL WHERE JOB_ID=0 LIMIT 200000;
※LIMIT句を付けないと、以下のエラーが出てしまう可能性がある。
The total number of locks exceeds the lｌｓock table size

SQLの例
SELECT GENDER,JOB_ID,COUNT(*) FROM CUSTOMER2 GROUP BY GENDER,JOB_ID;
SELECT GENDER,AGE,JOB_ID,COUNT(*) FROM CUSTOMER2 GROUP BY GENDER,AGE,JOB_ID;
SELECT COUNT(*) FROM CUSTOMER2 WHERE CUSTOMER_NAME LIKE '%ひろ%';

★SalesOne
・テーブル作成、データインポート
cd /work/init_data/sales_one
mysql -hlocalhost -P3306 -uroot DB_S < SALES_ONE_DDL_MYSQL.sql
mysql -hlocalhost -P3306 -uroot DB_S < SALES_ONE_LOAD_TO_MYSQL.sql

・SQLの例(1)
SELECT PRODUCT_ID, COUNT(*) FROM SALES_ONE
WHERE PRODUCT_ID LIKE 'A-%'
GROUP BY PRODUCT_ID;

・SQLの例(2)
SELECT REPLACE(PRODUCT_ID, '-', ''), COUNT(*) FROM SALES_ONE
WHERE PRODUCT_ID LIKE 'A-%'
GROUP BY PRODUCT_ID;

★Sales
テーブル作成、データインポート
cd /work/init_data/sales
mysql -hlocalhost -P3306 -uroot DB_S < SALES_DDL_MYSQL.sql
mysql -hlocalhost -P3306 -uroot DB_S < SALES_LOAD_TO_MYSQL.sql

★Sales Big
テーブル作成、データインポート
cd /work/init_data/sales_big
./SALES_DDL_MYSQL.sh
./SALES_LOAD_TO_MYSQL_0.sh
./SALES_LOAD_TO_MYSQL_SALES_TRAN_MAIN.sh
./SALES_LOAD_TO_MYSQL_SALES_DETAIL_MAIN.sh

※大量データをロードする場合は、以下にようにしないとパフォーマンスが悪いので注意。
・バイナリログの出力を抑止する。
・外部キー制約を設定しない。

データをすべてCSVファイルでエクスポートする
mysql -hlocalhost -P3306 -uroot DB_S < /work/init_data/sales_big/SALES_EXPORT_FROM_MYSQL.sql

★Sales B2B
テーブル作成、データインポート
cd /work/init_data/sales_b2b
mysql -hlocalhost -P3306 -uroot DB_S < SALES_B2B_DDL_MYSQL.sql
mysql -hlocalhost -P3306 -uroot DB_S < SALES_B2B_LOAD_TO_MYSQL.sql

SQLの例：
SELECT ST.CUSTOMER_ID, SD.PRODUCT_ID, COUNT(*) FROM SALES_TRAN ST JOIN SALES_DETAIL SD ON ST.SALES_ID = SD.SALES_ID
WHERE '2011-01-01' <= ST.SALES_DATE AND ST.SALES_DATE <= '2011-12-31'
GROUP BY ST.CUSTOMER_ID, SD.PRODUCT_ID;

// 2015年1月6日に売れた商品
SELECT ST.SALES_DATE, ST.CUSTOMER_ID, SD.PRODUCT_ID FROM SALES_TRAN ST JOIN SALES_DETAIL SD ON ST.SALES_ID = SD.SALES_ID
WHERE ST.SALES_DATE = '2015-01-06';

// 2015年1月6日に売れた商品個数（顧客・商品別）
SELECT ST.CUSTOMER_ID, SD.PRODUCT_ID, COUNT(*) FROM SALES_TRAN ST JOIN SALES_DETAIL SD ON ST.SALES_ID = SD.SALES_ID
WHERE ST.SALES_DATE = '2015-01-06'
GROUP BY ST.CUSTOMER_ID, SD.PRODUCT_ID;

◎ストアードプロシージャによるSQLバッチ
// ストアードプロシージャの登録
mysql -hlocalhost -P3306 -uroot DB_S < UPDATE_STOCK_BY_DATE_2.sql

// ストアードプロシージャの実行
call UPDATE_STOCK_PRODUCT('2015-09-10');

// これはテスト前に実施する （在庫を元に戻す）
UPDATE DB_S.STOCK_PRODUCT SET QUANTITY = 1000;
UPDATE DB_S.SALES_TRAN SET UPDATE_STOCK_FLAG = 0;

// このSQLで2015-09-10における各商品の売上個数をチェックする。
// 商品ID3000は、35個の売上がある。
SELECT SD.PRODUCT_ID, SUM(SD.SALES_COUNT) FROM DB_S.SALES_TRAN AS ST LEFT JOIN DB_S.SALES_DETAIL AS SD ON ST.SALES_ID = SD.SALES_ID
WHERE ST.SALES_DATE = '2015-09-10'
GROUP BY SD.PRODUCT_ID;

// 更新のあった在庫を確認する
SELECT * FROM STOCK_PRODUCT WHERE QUANTITY != 1000;

// これはテスト後に実施。1000-35で965になっていればOK。
SELECT * FROM DB_S.STOCK_PRODUCT WHERE PRODUCT_ID = 3000;

// これもテスト後に実施。ヒット件数が73件で、すべてフラグが1になっていればOK。
SELECT * FROM DB_S.SALES_TRAN WHERE SALES_DATE = '2015-09-10';

// 売れた商品個数。35になればOK。
SELECT SUM(SL.SALES_COUNT) FROM DB_S.SALES_TRAN ST INNER JOIN DB_S.SALES_DETAIL SL ON ST.SALES_ID = SL.SALES_ID
WHERE ST.SALES_DATE = '2015-09-10' AND SL.PRODUCT_ID = 3000;

◎分析処理
// 2015年1月の売り上げが大きい顧客（大きい方ら順にソートして表示）
SELECT ST.CUSTOMER_ID, SUM(SD.PRODUCT_PRICE * SD.SALES_COUNT) AS SALES_AMOUNT
FROM SALES_TRAN ST
INNER JOIN SALES_DETAIL SD ON ST.SALES_ID = SD.SALES_ID
WHERE DATE_FORMAT(ST.SALES_DATE, '%Y%m') = '201501'
GROUP BY ST.CUSTOMER_ID
ORDER BY SALES_AMOUNT DESC;

// 上記の確認用SQL
SELECT ST.CUSTOMER_ID, SD.PRODUCT_PRICE, SD.SALES_COUNT
FROM SALES_TRAN ST
LEFT JOIN SALES_DETAIL SD ON ST.SALES_ID = SD.SALES_ID
WHERE DATE_FORMAT(ST.SALES_DATE, '%Y%m') = '201501'
AND ST.CUSTOMER_ID = '99';

◎2015年1月の前年同月と比べて売り上げが伸びた顧客


方法その1：ビューを使う
DROP VIEW THIS_SALES;
DROP VIEW PREV_SALES;

CREATE VIEW THIS_SALES
AS SELECT ST.CUSTOMER_ID, SUM(SD.PRODUCT_PRICE * SD.SALES_COUNT) AS SALES_AMOUNT
FROM SALES_TRAN ST INNER JOIN SALES_DETAIL SD
ON ST.SALES_ID = SD.SALES_ID
WHERE DATE_FORMAT(ST.SALES_DATE, '%Y%m') = '201501'
GROUP BY ST.CUSTOMER_ID;

CREATE VIEW PREV_SALES
AS SELECT ST.CUSTOMER_ID, SUM(SD.PRODUCT_PRICE * SD.SALES_COUNT) AS SALES_AMOUNT
FROM SALES_TRAN ST INNER JOIN SALES_DETAIL SD
ON ST.SALES_ID = SD.SALES_ID
WHERE DATE_FORMAT(ST.SALES_DATE, '%Y%m') = '201401'
GROUP BY ST.CUSTOMER_ID;

SELECT THIS_SALES.CUSTOMER_ID, THIS_SALES.SALES_AMOUNT, PREV_SALES.SALES_AMOUNT,
THIS_SALES.SALES_AMOUNT - PREV_SALES.SALES_AMOUNT AS SALES_AMOUNT_DIFF
FROM THIS_SALES INNER JOIN PREV_SALES
ON THIS_SALES.CUSTOMER_ID = PREV_SALES.CUSTOMER_ID
ORDER BY SALES_AMOUNT_DIFF DESC;

方法その2：中間テーブル
CREATE TEMPORARY TABLE THIS_SALES
SELECT ST.CUSTOMER_ID, SUM(SD.PRODUCT_PRICE * SD.SALES_COUNT) AS THIS_SALES_AMOUNT
FROM SALES_TRAN ST INNER JOIN SALES_DETAIL SD
ON ST.SALES_ID = SD.SALES_ID
WHERE DATE_FORMAT(ST.SALES_DATE, '%Y%m') = '201501'
GROUP BY ST.CUSTOMER_ID;

CREATE TEMPORARY TABLE PREV_SALES
SELECT ST.CUSTOMER_ID, SUM(SD.PRODUCT_PRICE * SD.SALES_COUNT) AS PREV_SALES_AMOUNT
FROM SALES_TRAN ST INNER JOIN SALES_DETAIL SD
ON ST.SALES_ID = SD.SALES_ID
WHERE DATE_FORMAT(ST.SALES_DATE, '%Y%m') = '201401'
GROUP BY ST.CUSTOMER_ID;

SELECT THIS_SALES.CUSTOMER_ID, THIS_SALES_AMOUNT, PREV_SALES_AMOUNT,
THIS_SALES_AMOUNT - PREV_SALES_AMOUNT AS SALES_AMOUNT_DIFF
FROM THIS_SALES INNER JOIN PREV_SALES
ON THIS_SALES.CUSTOMER_ID = PREV_SALES.CUSTOMER_ID
ORDER BY SALES_AMOUNT_DIFF DESC;

方法その3：
SELECT ST1.CUSTOMER_ID, SUM(SD1.PRODUCT_PRICE * SD1.SALES_COUNT) AS THIS_SALES_AMOUNT,
PREV_SALES_AMOUNT,
SUM(SD1.PRODUCT_PRICE * SD1.SALES_COUNT) - PREV_SALES_AMOUNT AS SALES_AMOUNT_DIFF
FROM SALES_TRAN ST1
INNER JOIN SALES_DETAIL SD1 ON ST1.SALES_ID = SD1.SALES_ID
INNER JOIN (
    SELECT ST2.CUSTOMER_ID, SUM(SD2.PRODUCT_PRICE * SD2.SALES_COUNT) AS PREV_SALES_AMOUNT
    FROM SALES_TRAN ST2 INNER JOIN SALES_DETAIL SD2 ON ST2.SALES_ID = SD2.SALES_ID
    WHERE DATE_FORMAT(ST2.SALES_DATE, '%Y%m') = '201401'
    GROUP BY ST2.CUSTOMER_ID
    ) AS PREV
ON ST1.CUSTOMER_ID = PREV.CUSTOMER_ID
WHERE DATE_FORMAT(ST1.SALES_DATE, '%Y%m') = '201501'
GROUP BY ST1.CUSTOMER_ID
ORDER BY SALES_AMOUNT_DIFF DESC;

◎条件分岐
支払い期日まで3日以内の取引データに"ALERT"フラグを、4〜7日の取引データに"WARN"フラグを立てる。

方法その1：UNION句
SELECT SALES_ID, "ALERT" FROM SALES_TRAN
WHERE DATEDIFF(DUE_DATE, CURRENT_DATE()) < 4
UNION
SELECT SALES_ID, "WARN" FROM SALES_TRAN
WHERE DATEDIFF(DUE_DATE, CURRENT_DATE()) BETWEEN 4 AND 7;

方法その2：CASE句
SELECT SALES_ID,
    CASE WHEN DATEDIFF(DUE_DATE, CURRENT_DATE()) < 4 THEN "ALERT"
    WHEN DATEDIFF(DUE_DATE, CURRENT_DATE()) BETWEEN 4 AND 7 THEN "WARN"
    ELSE NULL END AS FLAG
FROM SALES_TRAN;

◎条件分岐2
縦持ち
SELECT BRANCH_ID, WEEKDAY(SALES_DATE), COUNT(*) FROM SALES_TRAN
GROUP BY BRANCH_ID, WEEKDAY(SALES_DATE);

横持ち
SELECT BRANCH_ID,
SUM(CASE WHEN WEEKDAY(SALES_DATE) = 0 THEN 1 ELSE 0 END) AS MONDAY,
SUM(CASE WHEN WEEKDAY(SALES_DATE) = 1 THEN 1 ELSE 0 END) AS TUESDAY,
SUM(CASE WHEN WEEKDAY(SALES_DATE) = 2 THEN 1 ELSE 0 END) AS WEDNESDAY,
SUM(CASE WHEN WEEKDAY(SALES_DATE) = 3 THEN 1 ELSE 0 END) AS THURSDAY,
SUM(CASE WHEN WEEKDAY(SALES_DATE) = 4 THEN 1 ELSE 0 END) AS FRIDAY
FROM SALES_TRAN
GROUP BY BRANCH_ID;
